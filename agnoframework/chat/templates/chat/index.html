<!DOCTYPE html>
<html>
<head>
    <title>AI VENDAS</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    {% load static %}
    <link rel="stylesheet" type="text/css" href="{% static 'chat/style.css' %}">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Google+Sans:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body>
    <div class="app-container">
        <div class="sidebar">
            <h2>HistÃ³rico de Conversas</h2>
            <a href="{% url 'new_chat' %}" class="new-chat-button">Nova Conversa</a>
            <ul>
                {% for conv in conversations %}
                    <li>
                        <a href="{% url 'index' conv.id %}" class="{% if conv.id == conversation.id %}active{% endif %}">
                            {{ conv.title|default:"Nova Conversa" }}
                        </a>
                        <form action="{% url 'delete_chat' conv.id %}" method="post" class="delete-chat-form">
                            {% csrf_token %}
                            <button type="submit" class="delete-chat-button" title="Apagar histÃ³rico">Ã—</button>
                        </form>
                    </li>
                {% endfor %}
            </ul>
        </div>
        <div class="chat-container">
            <div class="chat-header">
                <button id="menu-toggle" class="menu-toggle">â˜°</button>
                <h1 class="page-title">IA EXPERT EM VENDAS</h1>
            </div>
        <div class="chat-history">
            <div class="chat-history-wrapper">
            {% for message in conversation.history %}
                <div class="message {{ message.sender }}">
                    {% if message.sender == 'bot' %}
                        <div class="avatar bot-avatar">ðŸ¤–</div>
                    {% endif %}
                    <div class="message-content">{{ message.text|escape }}</div>
                </div>
            {% endfor %}
            </div>
        </div>
        <script>
            // Parse existing messages' markdown into HTML on load
            document.addEventListener('DOMContentLoaded', () => {
                document.querySelectorAll('.chat-history .message-content').forEach(contentDiv => {
                    const txt = contentDiv.textContent || '';
                    contentDiv.innerHTML = marked.parse(txt);
                });
            });
        </script>
        <div class="chat-input">
            {% csrf_token %}
            <input type="text" id="user-message" placeholder="Digite sua mensagem...">
            <button id="send-button">Enviar</button>
        </div>
    </div>
</div>

    <script>
        const sendButton = document.getElementById('send-button');
        const messageInput = document.getElementById('user-message');
        const chatHistoryDiv = document.querySelector('.chat-history-wrapper');
        const menuToggle = document.getElementById('menu-toggle');
        const sidebar = document.querySelector('.sidebar');
        
        // Mobile menu toggle
        menuToggle.addEventListener('click', () => {
            sidebar.classList.toggle('show');
        });

        // Close sidebar when clicking outside on mobile
        document.addEventListener('click', (e) => {
            if (window.innerWidth <= 768 && 
                !sidebar.contains(e.target) && 
                !menuToggle.contains(e.target) && 
                sidebar.classList.contains('show')) {
                sidebar.classList.remove('show');
            }
        });
        const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]').value;

        const currentConversationId = "{{ conversation.id }}";

        function sendMessage() {
            const userMessage = messageInput.value;
            if (userMessage.trim() === '') {
                return;
            }

            const userMessageDiv = document.createElement('div');
            userMessageDiv.classList.add('message', 'user');
            const userContent = document.createElement('div');
            userContent.classList.add('message-content');
            userContent.textContent = userMessage;
            userContent.innerHTML = marked.parse(userContent.textContent);
            userMessageDiv.appendChild(userContent);
            chatHistoryDiv.appendChild(userMessageDiv);

            messageInput.value = '';

            fetch(`/chat/${currentConversationId}/get_response/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrfToken
                },
                body: JSON.stringify({
                    'userMessage': userMessage
                })
            })
                .then(response => {
                    if (!response.ok) {
                        // Handle HTTP errors
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    const agentResponse = data.agentResponse;
                    const botMessageDiv = document.createElement('div');
                    botMessageDiv.classList.add('message', 'bot');
                    const botContent = document.createElement('div');
                    botContent.classList.add('message-content');
                    botMessageDiv.appendChild(botContent);
                    chatHistoryDiv.appendChild(botMessageDiv);

                    let i = 0;
                    const speed = 20; // Typing speed in milliseconds per character
                    let typedText = '';

                    function typeMessage() {
                        if (i < agentResponse.length) {
                            typedText += agentResponse.charAt(i);
                            botContent.innerHTML = marked.parse(typedText);
                            i++;
                            // Keep the view near the bottom while the bot "types"
                            scrollToBottom(false);
                            setTimeout(typeMessage, speed);
                        } else {
                            // Ensure final markdown is parsed and scroll to bottom (smooth)
                            botContent.innerHTML = marked.parse(agentResponse);
                            scrollToBottom(true);
                        }
                    }
                    typeMessage();
                })
                .catch(error => {
                    console.error('Error sending message:', error);
                    // Optionally, display an error message to the user
                    const errorMessageDiv = document.createElement('div');
                    errorMessageDiv.classList.add('message', 'bot', 'error');
                    errorMessageDiv.innerHTML = '<div class="message-content">Ocorreu um erro ao enviar sua mensagem. Por favor, tente novamente.</div>';
                    chatHistoryDiv.appendChild(errorMessageDiv);
                    scrollToBottom(true);
                });
        }

        sendButton.addEventListener('click', sendMessage);

        messageInput.addEventListener('keydown', function(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        });

        // Scroll helper: ensure full content is visible after render
        function scrollToBottom(smooth = false) {
            try {
                const el = chatHistoryDiv;
                if (!el) return;
                const pos = el.scrollHeight;
                if (smooth && 'scrollTo' in el) {
                    el.scrollTo({ top: pos, behavior: 'smooth' });
                } else {
                    el.scrollTop = pos;
                }
            } catch (e) {
                console.warn('scrollToBottom failed', e);
            }
        }

        // Auto-scroll when new messages or content changes so refresh won't leave partial content off-screen
        const observer = new MutationObserver((mutations) => {
            // small debounce
            clearTimeout(window.__chat_scroll_timeout);
            window.__chat_scroll_timeout = setTimeout(() => scrollToBottom(true), 30);
        });
        if (chatHistoryDiv) {
            observer.observe(chatHistoryDiv, { childList: true, subtree: true, characterData: true });
        }

        // Ensure we scroll after initial markdown parsing/render
        window.addEventListener('load', () => {
            // Give browser a tick to finish layout then scroll (smooth)
            requestAnimationFrame(() => requestAnimationFrame(() => scrollToBottom(true)));
        });

        // When the input is focused (keyboard opens on mobile), scroll the chat to bottom
        messageInput.addEventListener('focus', () => {
            // delay slightly for mobile keyboard/viewport resize
            setTimeout(() => scrollToBottom(true), 250);
        });

        // Some mobile browsers fire resize when keyboard opens; ensure we scroll then as well
        let _resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(_resizeTimer);
            _resizeTimer = setTimeout(() => scrollToBottom(true), 200);
        });
    </script>
</body>
</html>